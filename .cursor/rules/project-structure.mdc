---
description: 
globs: 
alwaysApply: true
---
Below is an explanation of the app, frontend, and server directories in your Leptos Axum starter project, based on your provided structure and typical conventions for a Leptos + Axum workspace setup.
app Directory

    Structure: 

    app
    ├── Cargo.toml
    └── src
        └── lib.rs

    Purpose: This directory contains the core Leptos application logic, acting as a library crate (due to src/lib.rs). It defines the shared components, state management, and UI logic that make up your web application.
    Role: 
        Houses reusable Leptos components (e.g., using #[component] macro) and application-specific functionality.
        Designed to be compiled for both server-side rendering (SSR) and client-side WebAssembly (WASM), often using conditional compilation (e.g., #[cfg(target_arch = "wasm32")] for client-specific code).
        Acts as a dependency for both frontend and server, ensuring the same app logic is used across environments.
    Key File: 
        src/lib.rs: Likely contains the main application code, such as component definitions and shared utilities. For example:
        rust

        use leptos::*;
        #[component]
        pub fn App() -> impl IntoView {
            view! { <h1>"My Leptos App"</h1> }
        }

    Why It Exists: Separates the application logic from the delivery mechanisms (server or client), promoting modularity and reusability.

frontend Directory

    Structure: 

    frontend
    ├── Cargo.toml
    └── src
        └── lib.rs

    Purpose: This directory is responsible for building the client-side portion of the application, compiling the Leptos app (from the app crate) into WebAssembly (WASM) for browser execution. It’s also a library crate.
    Role: 
        Depends on the app crate and sets up the client-side entry point for WASM.
        Handles hydration, where the server-rendered HTML is made interactive in the browser by attaching Leptos’s reactive system.
        Compiled with the wasm32-unknown-unknown target, producing a WASM binary (e.g., in target/wasm32-unknown-unknown).
    Key File: 
        src/lib.rs: Typically defines the hydration logic, linking the app components to the browser. Example:
        rust

        use app::App;
        use leptos::*;
        #[wasm_bindgen]
        pub fn hydrate() {
            mount_to_body(|| view! { <App/> });
        }

    Why It Exists: Isolates client-side concerns (WASM compilation, browser runtime setup) from the shared app logic, allowing the app crate to remain environment-agnostic.

server Directory

    Structure: 

    server
    ├── Cargo.toml
    └── src
        ├── fileserv.rs
        └── main.rs

    Purpose: This directory contains the Axum server implementation, acting as a binary crate (due to src/main.rs). It serves the application, handles HTTP requests, and performs server-side rendering (SSR) using the app crate.
    Role: 
        Sets up an Axum web server with routes for serving static files (e.g., WASM, CSS), rendering the Leptos app on the server, and handling API requests or server functions.
        Integrates with Leptos (via leptos_axum) to render the app components into HTML on the server, which is then sent to the client.
        Serves the WASM binary (from frontend) and static assets (e.g., from public) to enable client-side hydration.
    Key Files: 
        src/main.rs: The entry point for the server, setting up Axum and Leptos integration. Example:
        rust

        use axum::{Router, routing::get};
        use leptos::*;
        use leptos_axum::{generate_route_list, LeptosRoutes};
        use app::App;

        #[tokio::main]
        async fn main() {
            let leptos_options = LeptosOptions::builder().output_name("app").build();
            let app = Router::new()
                .leptos_routes(&leptos_options, generate_route_list(App), App)
                .with_state(leptos_options);
            axum::Server::bind(&"0.0.0.0:3000".parse().unwrap())
                .serve(app.into_make_service())
                .await
                .unwrap();
        }

        src/fileserv.rs: Likely a module for serving static files (e.g., WASM, favicon), keeping this logic separate from the main server setup.
    Why It Exists: Manages server-specific tasks (HTTP handling, SSR, file serving), distinct from the application logic in app and client build in frontend.

How They Work Together

    App: Defines the shared Leptos application (components, logic).
    Server: Uses app to render the initial HTML (SSR) and serves it, along with the WASM binary and static assets, to the client.
    Frontend: Uses app to compile the WASM binary, which the browser loads to hydrate the server-rendered HTML, enabling interactivity.

Example Flow

    A user visits your site:
        server renders the App component from app into HTML and sends it to the browser.
        server also serves the WASM file (from frontend) and static assets (e.g., favicon.ico).
        The browser loads the WASM, and frontend’s hydration logic (e.g., hydrate()) attaches reactivity to the HTML, making it interactive.

Why Separate These Three?

    Modularity: Each directory has a clear responsibility (app for logic, frontend for client, server for server), making the project easier to maintain and scale.
    Reusability: app can be reused across server and client without duplication.
    Build Flexibility: Separate crates allow independent compilation and dependency management (e.g., server might need axum, while frontend needs wasm-bindgen).

This structure aligns with the start-axum-workspace template from Leptos, designed for larger projects where separation of concerns is beneficial, though it adds some complexity compared to a single-crate setup.
Summary

    app: Core Leptos app logic (shared library).
    frontend: Client-side WASM build (library for browser).
    server: Axum server with SSR and file serving (binary).

Together, they form a full-stack web app with SSR and client-side interactivity, leveraging Rust’s workspace system for organization.